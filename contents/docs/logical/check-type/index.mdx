---
title: Check Type
description: Determine the data type of a value.
---

## Overview

The check type function identifies and returns the data type classification of a given value. This introspection operation is essential for dynamic type checking and conditional processing in programming.

## Usage

```python
from taizun import check_type
value = 10
result = check_type(value)
print(result)
```

## Theory

Type checking is a fundamental operation in programming that determines the category or class of a value according to the type system of the language. This enables conditional behavior based on data characteristics.

Type categories typically include:
1. **Primitive types**: int, float, bool, str, etc.
2. **Composite types**: list, dict, tuple, set, etc.
3. **Custom types**: User-defined classes and structures
4. **Special types**: None, function, module, etc.

Implementation approaches:
1. **Built-in functions**: Language-specific type inspection functions
2. **Reflection APIs**: Runtime type information systems
3. **Pattern matching**: Modern language constructs for type discrimination
4. **Manual checking**: Explicit isinstance or type comparisons

Applications include:
- **Dynamic dispatch**: Executing different code paths based on type
- **Data validation**: Ensuring inputs match expected types
- **Serialization**: Converting values to appropriate string representations
- **Debugging**: Inspecting variable types during development
- **Generic programming**: Writing functions that work with multiple types
- **Error handling**: Providing type-specific error messages

Considerations in type systems:
- **Static vs. dynamic**: Compile-time vs. runtime type checking
- **Strong vs. weak**: Enforcement of type constraints
- **Nominal vs. structural**: Name-based vs. structure-based type equivalence
- **Type hierarchies**: Inheritance and interface relationships

In programming:
```python
# Python examples
type(value).__name__          # Get type name
isinstance(value, int)        # Check specific type
isinstance(value, (int, float))  # Check multiple types
```

Type checking is crucial for writing robust, maintainable code that handles different data types appropriately while preventing type-related errors.

## Real-World Example

Data processing systems and application development use type checking to validate inputs, handle different data formats, and implement conditional logic in various business and technical contexts:

```python
from taizun import check_type

# Data validation for API inputs
def validate_api_inputs(input_data):
    """
    Validate API inputs by checking data types
    """
    validation_results = []
    
    for key, value in input_data.items():
        value_type = check_type(value)
        
        # Define expected types for each field
        expected_types = {
            "user_id": "int",
            "username": "str",
            "is_active": "bool",
            "scores": "list",
            "metadata": "dict",
            "balance": "float"
        }
        
        expected_type = expected_types.get(key, "any")
        is_valid = expected_type == "any" or value_type == expected_type
        
        validation_results.append({
            "field": key,
            "value": value,
            "type": value_type,
            "expected": expected_type,
            "valid": is_valid
        })
    
    return validation_results

# Example API input data
api_input = {
    "user_id": 12345,
    "username": "john_doe",
    "is_active": True,
    "scores": [85, 92, 78],
    "metadata": {"department": "engineering", "level": "senior"},
    "balance": 1250.75
}

validation_results = validate_api_inputs(api_input)

print("API Input Validation:")
print("=" * 19)
for result in validation_results:
    status = "✓ Valid" if result['valid'] else "✗ Invalid"
    print(f"  {result['field']}: {result['type']} (expected: {result['expected']}) - {status}")

# Dynamic data processor
def process_data_dynamically(data_list):
    """
    Process different data types with appropriate handlers
    """
    processed_results = []
    
    for item in data_list:
        item_type = check_type(item)
        
        if item_type == "int":
            # Process integers (e.g., counts, IDs)
            result = f"Integer processed: {item * 2}"
        elif item_type == "str":
            # Process strings (e.g., names, messages)
            result = f"String processed: {item.upper()}"
        elif item_type == "list":
            # Process lists (e.g., arrays of data)
            result = f"List processed: {len(item)} items"
        elif item_type == "dict":
            # Process dictionaries (e.g., structured data)
            result = f"Dictionary processed: {len(item)} keys"
        elif item_type == "float":
            # Process floats (e.g., measurements, prices)
            result = f"Float processed: {round(item, 2)}"
        elif item_type == "bool":
            # Process booleans (e.g., flags, statuses)
            result = f"Boolean processed: {'Yes' if item else 'No'}"
        else:
            result = f"Unknown type {item_type}: {item}"
        
        processed_results.append(result)
    
    return processed_results

# Example mixed data types
mixed_data = [
    42,                    # int
    "hello world",         # str
    [1, 2, 3, 4, 5],      # list
    {"name": "John", "age": 30},  # dict
    3.14159,              # float
    True,                 # bool
    None                  # NoneType
]

processed_data = process_data_dynamically(mixed_data)

print("\nDynamic Data Processing:")
print("=" * 22)
for i, result in enumerate(processed_data):
    print(f"  {i+1}. {result}")

# Configuration file parser with type-aware handling
def parse_config_with_types(config_data):
    """
    Parse configuration data with automatic type detection
    """
    parsed_config = {}
    
    for key, value in config_data.items():
        # Check the type of the value
        value_type = check_type(value)
        
        # Apply appropriate parsing based on type
        if value_type == "str":
            # Try to convert string values to appropriate types
            if value.lower() in ["true", "false"]:
                parsed_config[key] = value.lower() == "true"
            elif value.isdigit():
                parsed_config[key] = int(value)
            elif value.replace('.', '').isdigit():
                parsed_config[key] = float(value)
            else:
                parsed_config[key] = value
        else:
            # Keep other types as they are
            parsed_config[key] = value
    
    return parsed_config

# Example configuration data
config_data = {
    "debug_mode": "true",
    "max_connections": "100",
    "timeout": "30.5",
    "server_name": "web-server-01",
    "retry_count": 3,
    "ssl_enabled": True
}

parsed_config = parse_config_with_types(config_data)

print("\nConfiguration Parsing with Type Detection:")
print("=" * 40)
print("Original config:")
for key, value in config_data.items():
    print(f"  {key}: {value} ({check_type(value)})")

print("\nParsed config:")
for key, value in parsed_config.items():
    print(f"  {key}: {value} ({check_type(value)})")

# Data serialization handler
def serialize_data_for_storage(data_items):
    """
    Serialize different data types for storage with type information
    """
    serialized_items = []
    
    for item in data_items:
        item_type = check_type(item)
        
        # Create serialized representation with type information
        if item_type == "str":
            serialized = f"str:{item}"
        elif item_type == "int":
            serialized = f"int:{item}"
        elif item_type == "float":
            serialized = f"float:{item}"
        elif item_type == "bool":
            serialized = f"bool:{str(item).lower()}"
        elif item_type == "list":
            serialized = f"list:{str(item)}"
        elif item_type == "dict":
            serialized = f"dict:{str(item)}"
        else:
            serialized = f"unknown:{str(item)}"
        
        serialized_items.append(serialized)
    
    return serialized_items

# Example data for serialization
data_for_serialization = [
    "Hello, World!",
    42,
    3.14,
    True,
    [1, 2, 3],
    {"key": "value"}
]

serialized_data = serialize_data_for_storage(data_for_serialization)

print("\nData Serialization with Type Information:")
print("=" * 38)
print("Original data:")
for item in data_for_serialization:
    print(f"  {item} ({check_type(item)})")

print("\nSerialized data:")
for item in serialized_data:
    print(f"  {item}")

# Error handling with type-specific messages
def handle_data_with_type_errors(data_list):
    """
    Handle data processing with type-specific error messages
    """
    results = []
    
    for item in data_list:
        item_type = check_type(item)
        
        try:
            if item_type == "int":
                # Process integer
                result = item * 2
            elif item_type == "str":
                # Process string
                result = item.upper()
            elif item_type == "list":
                # Process list
                result = len(item)
            elif item_type == "dict":
                # Process dictionary
                result = list(item.keys())
            else:
                # Unsupported type
                raise TypeError(f"Unsupported data type: {item_type}")
            
            results.append({
                "input": item,
                "type": item_type,
                "result": result,
                "status": "Success"
            })
            
        except Exception as e:
            results.append({
                "input": item,
                "type": item_type,
                "result": None,
                "status": f"Error: {str(e)}"
            })
    
    return results

# Example data with potential type issues
data_with_issues = [
    10,           # int - valid
    "test",       # str - valid
    [1, 2, 3],    # list - valid
    {"a": 1},     # dict - valid
    lambda x: x,  # function - unsupported
    {1, 2, 3}     # set - unsupported
]

processed_with_errors = handle_data_with_type_errors(data_with_issues)

print("\nType-Aware Error Handling:")
print("=" * 25)
for result in processed_with_errors:
    print(f"  Input: {result['input']} ({result['type']})")
    print(f"  Result: {result['result']}")
    print(f"  Status: {result['status']}")
    print()
```

These examples demonstrate how type checking is used for API validation, dynamic data processing, configuration parsing, data serialization, and error handling in real-world applications.